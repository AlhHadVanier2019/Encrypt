import csv
import math
import random
import socket
import threading
import time

import Operators as op

# Global Variable used for communications with AES and 3DES
socketHolder = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

class AES:
    """
    Creates an aes object which can encrypt and decrypt any message or file given a key using the encrypt
    and decrypt methods.
    """

    # ------INITIALIZE NECESSARY LOOKUP TABLES----------
    # Rijndael S-box
    sbox = ['01100011', '01111100', '01110111', '01111011', '11110010', '01101011', '01101111', '11000101',
            '00110000', '00000001', '01100111', '00101011', '11111110', '11010111', '10101011', '01110110',
            '11001010', '10000010', '11001001', '01111101', '11111010', '01011001', '01000111', '11110000',
            '10101101', '11010100', '10100010', '10101111', '10011100', '10100100', '01110010', '11000000',
            '10110111', '11111101', '10010011', '00100110', '00110110', '00111111', '11110111', '11001100',
            '00110100', '10100101', '11100101', '11110001', '01110001', '11011000', '00110001', '00010101',
            '00000100', '11000111', '00100011', '11000011', '00011000', '10010110', '00000101', '10011010',
            '00000111', '00010010', '10000000', '11100010', '11101011', '00100111', '10110010', '01110101',
            '00001001', '10000011', '00101100', '00011010', '00011011', '01101110', '01011010', '10100000',
            '01010010', '00111011', '11010110', '10110011', '00101001', '11100011', '00101111', '10000100',
            '01010011', '11010001', '00000000', '11101101', '00100000', '11111100', '10110001', '01011011',
            '01101010', '11001011', '10111110', '00111001', '01001010', '01001100', '01011000', '11001111',
            '11010000', '11101111', '10101010', '11111011', '01000011', '01001101', '00110011', '10000101',
            '01000101', '11111001', '00000010', '01111111', '01010000', '00111100', '10011111', '10101000',
            '01010001', '10100011', '01000000', '10001111', '10010010', '10011101', '00111000', '11110101',
            '10111100', '10110110', '11011010', '00100001', '00010000', '11111111', '11110011', '11010010',
            '11001101', '00001100', '00010011', '11101100', '01011111', '10010111', '01000100', '00010111',
            '11000100', '10100111', '01111110', '00111101', '01100100', '01011101', '00011001', '01110011',
            '01100000', '10000001', '01001111', '11011100', '00100010', '00101010', '10010000', '10001000',
            '01000110', '11101110', '10111000', '00010100', '11011110', '01011110', '00001011', '11011011',
            '11100000', '00110010', '00111010', '00001010', '01001001', '00000110', '00100100', '01011100',
            '11000010', '11010011', '10101100', '01100010', '10010001', '10010101', '11100100', '01111001',
            '11100111', '11001000', '00110111', '01101101', '10001101', '11010101', '01001110', '10101001',
            '01101100', '01010110', '11110100', '11101010', '01100101', '01111010', '10101110', '00001000',
            '10111010', '01111000', '00100101', '00101110', '00011100', '10100110', '10110100', '11000110',
            '11101000', '11011101', '01110100', '00011111', '01001011', '10111101', '10001011', '10001010',
            '01110000', '00111110', '10110101', '01100110', '01001000', '00000011', '11110110', '00001110',
            '01100001', '00110101', '01010111', '10111001', '10000110', '11000001', '00011101', '10011110',
            '11100001', '11111000', '10011000', '00010001', '01101001', '11011001', '10001110', '10010100',
            '10011011', '00011110', '10000111', '11101001', '11001110', '01010101', '00101000', '11011111',
            '10001100', '10100001', '10001001', '00001101', '10111111', '11100110', '01000010', '01101000',
            '01000001', '10011001', '00101101', '00001111', '10110000', '01010100', '10111011', '00010110']

    # Galois field multiplication by 2
    mul2 = ['00000000', '00000010', '00000100', '00000110', '00001000', '00001010', '00001100', '00001110',
            '00010000', '00010010', '00010100', '00010110', '00011000', '00011010', '00011100', '00011110',
            '00100000', '00100010', '00100100', '00100110', '00101000', '00101010', '00101100', '00101110',
            '00110000', '00110010', '00110100', '00110110', '00111000', '00111010', '00111100', '00111110',
            '01000000', '01000010', '01000100', '01000110', '01001000', '01001010', '01001100', '01001110',
            '01010000', '01010010', '01010100', '01010110', '01011000', '01011010', '01011100', '01011110',
            '01100000', '01100010', '01100100', '01100110', '01101000', '01101010', '01101100', '01101110',
            '01110000', '01110010', '01110100', '01110110', '01111000', '01111010', '01111100', '01111110',
            '10000000', '10000010', '10000100', '10000110', '10001000', '10001010', '10001100', '10001110',
            '10010000', '10010010', '10010100', '10010110', '10011000', '10011010', '10011100', '10011110',
            '10100000', '10100010', '10100100', '10100110', '10101000', '10101010', '10101100', '10101110',
            '10110000', '10110010', '10110100', '10110110', '10111000', '10111010', '10111100', '10111110',
            '11000000', '11000010', '11000100', '11000110', '11001000', '11001010', '11001100', '11001110',
            '11010000', '11010010', '11010100', '11010110', '11011000', '11011010', '11011100', '11011110',
            '11100000', '11100010', '11100100', '11100110', '11101000', '11101010', '11101100', '11101110',
            '11110000', '11110010', '11110100', '11110110', '11111000', '11111010', '11111100', '11111110',
            '00011011', '00011001', '00011111', '00011101', '00010011', '00010001', '00010111', '00010101',
            '00001011', '00001001', '00001111', '00001101', '00000011', '00000001', '00000111', '00000101',
            '00111011', '00111001', '00111111', '00111101', '00110011', '00110001', '00110111', '00110101',
            '00101011', '00101001', '00101111', '00101101', '00100011', '00100001', '00100111', '00100101',
            '01011011', '01011001', '01011111', '01011101', '01010011', '01010001', '01010111', '01010101',
            '01001011', '01001001', '01001111', '01001101', '01000011', '01000001', '01000111', '01000101',
            '01111011', '01111001', '01111111', '01111101', '01110011', '01110001', '01110111', '01110101',
            '01101011', '01101001', '01101111', '01101101', '01100011', '01100001', '01100111', '01100101',
            '10011011', '10011001', '10011111', '10011101', '10010011', '10010001', '10010111', '10010101',
            '10001011', '10001001', '10001111', '10001101', '10000011', '10000001', '10000111', '10000101',
            '10111011', '10111001', '10111111', '10111101', '10110011', '10110001', '10110111', '10110101',
            '10101011', '10101001', '10101111', '10101101', '10100011', '10100001', '10100111', '10100101',
            '11011011', '11011001', '11011111', '11011101', '11010011', '11010001', '11010111', '11010101',
            '11001011', '11001001', '11001111', '11001101', '11000011', '11000001', '11000111', '11000101',
            '11111011', '11111001', '11111111', '11111101', '11110011', '11110001', '11110111', '11110101',
            '11101011', '11101001', '11101111', '11101101', '11100011', '11100001', '11100111', '11100101']

    # Galois field multiplication by 3
    mul3 = ['00000000', '00000011', '00000110', '00000101', '00001100', '00001111', '00001010', '00001001',
            '00011000', '00011011', '00011110', '00011101', '00010100', '00010111', '00010010', '00010001',
            '00110000', '00110011', '00110110', '00110101', '00111100', '00111111', '00111010', '00111001',
            '00101000', '00101011', '00101110', '00101101', '00100100', '00100111', '00100010', '00100001',
            '01100000', '01100011', '01100110', '01100101', '01101100', '01101111', '01101010', '01101001',
            '01111000', '01111011', '01111110', '01111101', '01110100', '01110111', '01110010', '01110001',
            '01010000', '01010011', '01010110', '01010101', '01011100', '01011111', '01011010', '01011001',
            '01001000', '01001011', '01001110', '01001101', '01000100', '01000111', '01000010', '01000001',
            '11000000', '11000011', '11000110', '11000101', '11001100', '11001111', '11001010', '11001001',
            '11011000', '11011011', '11011110', '11011101', '11010100', '11010111', '11010010', '11010001',
            '11110000', '11110011', '11110110', '11110101', '11111100', '11111111', '11111010', '11111001',
            '11101000', '11101011', '11101110', '11101101', '11100100', '11100111', '11100010', '11100001',
            '10100000', '10100011', '10100110', '10100101', '10101100', '10101111', '10101010', '10101001',
            '10111000', '10111011', '10111110', '10111101', '10110100', '10110111', '10110010', '10110001',
            '10010000', '10010011', '10010110', '10010101', '10011100', '10011111', '10011010', '10011001',
            '10001000', '10001011', '10001110', '10001101', '10000100', '10000111', '10000010', '10000001',
            '10011011', '10011000', '10011101', '10011110', '10010111', '10010100', '10010001', '10010010',
            '10000011', '10000000', '10000101', '10000110', '10001111', '10001100', '10001001', '10001010',
            '10101011', '10101000', '10101101', '10101110', '10100111', '10100100', '10100001', '10100010',
            '10110011', '10110000', '10110101', '10110110', '10111111', '10111100', '10111001', '10111010',
            '11111011', '11111000', '11111101', '11111110', '11110111', '11110100', '11110001', '11110010',
            '11100011', '11100000', '11100101', '11100110', '11101111', '11101100', '11101001', '11101010',
            '11001011', '11001000', '11001101', '11001110', '11000111', '11000100', '11000001', '11000010',
            '11010011', '11010000', '11010101', '11010110', '11011111', '11011100', '11011001', '11011010',
            '01011011', '01011000', '01011101', '01011110', '01010111', '01010100', '01010001', '01010010',
            '01000011', '01000000', '01000101', '01000110', '01001111', '01001100', '01001001', '01001010',
            '01101011', '01101000', '01101101', '01101110', '01100111', '01100100', '01100001', '01100010',
            '01110011', '01110000', '01110101', '01110110', '01111111', '01111100', '01111001', '01111010',
            '00111011', '00111000', '00111101', '00111110', '00110111', '00110100', '00110001', '00110010',
            '00100011', '00100000', '00100101', '00100110', '00101111', '00101100', '00101001', '00101010',
            '00001011', '00001000', '00001101', '00001110', '00000111', '00000100', '00000001', '00000010',
            '00010011', '00010000', '00010101', '00010110', '00011111', '00011100', '00011001', '00011010']

    # RCon Index
    rcon = ['10001101', '00000001', '00000010', '00000100', '00001000', '00010000', '00100000', '01000000',
            '10000000', '00011011', '00110110', '01101100', '11011000', '10101011', '01001101', '10011010',
            '00101111', '01011110', '10111100', '01100011', '11000110', '10010111', '00110101', '01101010',
            '11010100', '10110011', '01111101', '11111010', '11101111', '11000101', '10010001', '00111001',
            '01110010', '11100100', '11010011', '10111101', '01100001', '11000010', '10011111', '00100101',
            '01001010', '10010100', '00110011', '01100110', '11001100', '10000011', '00011101', '00111010',
            '01110100', '11101000', '11001011', '10001101', '00000001', '00000010', '00000100', '00001000',
            '00010000', '00100000', '01000000', '10000000', '00011011', '00110110', '01101100', '11011000',
            '10101011', '01001101', '10011010', '00101111', '01011110', '10111100', '01100011', '11000110',
            '10010111', '00110101', '01101010', '11010100', '10110011', '01111101', '11111010', '11101111',
            '11000101', '10010001', '00111001', '01110010', '11100100', '11010011', '10111101', '01100001',
            '11000010', '10011111', '00100101', '01001010', '10010100', '00110011', '01100110', '11001100',
            '10000011', '00011101', '00111010', '01110100', '11101000', '11001011', '10001101', '00000001',
            '00000010', '00000100', '00001000', '00010000', '00100000', '01000000', '10000000', '00011011',
            '00110110', '01101100', '11011000', '10101011', '01001101', '10011010', '00101111', '01011110',
            '10111100', '01100011', '11000110', '10010111', '00110101', '01101010', '11010100', '10110011',
            '01111101', '11111010', '11101111', '11000101', '10010001', '00111001', '01110010', '11100100',
            '11010011', '10111101', '01100001', '11000010', '10011111', '00100101', '01001010', '10010100',
            '00110011', '01100110', '11001100', '10000011', '00011101', '00111010', '01110100', '11101000',
            '11001011', '10001101', '00000001', '00000010', '00000100', '00001000', '00010000', '00100000',
            '01000000', '10000000', '00011011', '00110110', '01101100', '11011000', '10101011', '01001101',
            '10011010', '00101111', '01011110', '10111100', '01100011', '11000110', '10010111', '00110101',
            '01101010', '11010100', '10110011', '01111101', '11111010', '11101111', '11000101', '10010001',
            '00111001', '01110010', '11100100', '11010011', '10111101', '01100001', '11000010', '10011111',
            '00100101', '01001010', '10010100', '00110011', '01100110', '11001100', '10000011', '00011101',
            '00111010', '01110100', '11101000', '11001011', '10001101', '00000001', '00000010', '00000100',
            '00001000', '00010000', '00100000', '01000000', '10000000', '00011011', '00110110', '01101100',
            '11011000', '10101011', '01001101', '10011010', '00101111', '01011110', '10111100', '01100011',
            '11000110', '10010111', '00110101', '01101010', '11010100', '10110011', '01111101', '11111010',
            '11101111', '11000101', '10010001', '00111001', '01110010', '11100100', '11010011', '10111101',
            '01100001', '11000010', '10011111', '00100101', '01001010', '10010100', '00110011', '01100110',
            '11001100', '10000011', '00011101', '00111010', '01110100', '11101000', '11001011', '10001101']

    # -------INVERSE LOOKUP TABLES FOR DECRYPTION ----------
    # Inverse S-Box
    inv_sbox = ['01010010', '00001001', '01101010', '11010101', '00110000', '00110110', '10100101', '00111000',
                '10111111', '01000000', '10100011', '10011110', '10000001', '11110011', '11010111', '11111011',
                '01111100', '11100011', '00111001', '10000010', '10011011', '00101111', '11111111', '10000111',
                '00110100', '10001110', '01000011', '01000100', '11000100', '11011110', '11101001', '11001011',
                '01010100', '01111011', '10010100', '00110010', '10100110', '11000010', '00100011', '00111101',
                '11101110', '01001100', '10010101', '00001011', '01000010', '11111010', '11000011', '01001110',
                '00001000', '00101110', '10100001', '01100110', '00101000', '11011001', '00100100', '10110010',
                '01110110', '01011011', '10100010', '01001001', '01101101', '10001011', '11010001', '00100101',
                '01110010', '11111000', '11110110', '01100100', '10000110', '01101000', '10011000', '00010110',
                '11010100', '10100100', '01011100', '11001100', '01011101', '01100101', '10110110', '10010010',
                '01101100', '01110000', '01001000', '01010000', '11111101', '11101101', '10111001', '11011010',
                '01011110', '00010101', '01000110', '01010111', '10100111', '10001101', '10011101', '10000100',
                '10010000', '11011000', '10101011', '00000000', '10001100', '10111100', '11010011', '00001010',
                '11110111', '11100100', '01011000', '00000101', '10111000', '10110011', '01000101', '00000110',
                '11010000', '00101100', '00011110', '10001111', '11001010', '00111111', '00001111', '00000010',
                '11000001', '10101111', '10111101', '00000011', '00000001', '00010011', '10001010', '01101011',
                '00111010', '10010001', '00010001', '01000001', '01001111', '01100111', '11011100', '11101010',
                '10010111', '11110010', '11001111', '11001110', '11110000', '10110100', '11100110', '01110011',
                '10010110', '10101100', '01110100', '00100010', '11100111', '10101101', '00110101', '10000101',
                '11100010', '11111001', '00110111', '11101000', '00011100', '01110101', '11011111', '01101110',
                '01000111', '11110001', '00011010', '01110001', '00011101', '00101001', '11000101', '10001001',
                '01101111', '10110111', '01100010', '00001110', '10101010', '00011000', '10111110', '00011011',
                '11111100', '01010110', '00111110', '01001011', '11000110', '11010010', '01111001', '00100000',
                '10011010', '11011011', '11000000', '11111110', '01111000', '11001101', '01011010', '11110100',
                '00011111', '11011101', '10101000', '00110011', '10001000', '00000111', '11000111', '00110001',
                '10110001', '00010010', '00010000', '01011001', '00100111', '10000000', '11101100', '01011111',
                '01100000', '01010001', '01111111', '10101001', '00011001', '10110101', '01001010', '00001101',
                '00101101', '11100101', '01111010', '10011111', '10010011', '11001001', '10011100', '11101111',
                '10100000', '11100000', '00111011', '01001101', '10101110', '00101010', '11110101', '10110000',
                '11001000', '11101011', '10111011', '00111100', '10000011', '01010011', '10011001', '01100001',
                '00010111', '00101011', '00000100', '01111110', '10111010', '01110111', '11010110', '00100110',
                '11100001', '01101001', '00010100', '01100011', '01010101', '00100001', '00001100', '01111101']

    # Multiplication by 9
    mul9 = ['00000000', '00001001', '00010010', '00011011', '00100100', '00101101', '00110110', '00111111',
            '01001000', '01000001', '01011010', '01010011', '01101100', '01100101', '01111110', '01110111',
            '10010000', '10011001', '10000010', '10001011', '10110100', '10111101', '10100110', '10101111',
            '11011000', '11010001', '11001010', '11000011', '11111100', '11110101', '11101110', '11100111',
            '00111011', '00110010', '00101001', '00100000', '00011111', '00010110', '00001101', '00000100',
            '01110011', '01111010', '01100001', '01101000', '01010111', '01011110', '01000101', '01001100',
            '10101011', '10100010', '10111001', '10110000', '10001111', '10000110', '10011101', '10010100',
            '11100011', '11101010', '11110001', '11111000', '11000111', '11001110', '11010101', '11011100',
            '01110110', '01111111', '01100100', '01101101', '01010010', '01011011', '01000000', '01001001',
            '00111110', '00110111', '00101100', '00100101', '00011010', '00010011', '00001000', '00000001',
            '11100110', '11101111', '11110100', '11111101', '11000010', '11001011', '11010000', '11011001',
            '10101110', '10100111', '10111100', '10110101', '10001010', '10000011', '10011000', '10010001',
            '01001101', '01000100', '01011111', '01010110', '01101001', '01100000', '01111011', '01110010',
            '00000101', '00001100', '00010111', '00011110', '00100001', '00101000', '00110011', '00111010',
            '11011101', '11010100', '11001111', '11000110', '11111001', '11110000', '11101011', '11100010',
            '10010101', '10011100', '10000111', '10001110', '10110001', '10111000', '10100011', '10101010',
            '11101100', '11100101', '11111110', '11110111', '11001000', '11000001', '11011010', '11010011',
            '10100100', '10101101', '10110110', '10111111', '10000000', '10001001', '10010010', '10011011',
            '01111100', '01110101', '01101110', '01100111', '01011000', '01010001', '01001010', '01000011',
            '00110100', '00111101', '00100110', '00101111', '00010000', '00011001', '00000010', '00001011',
            '11010111', '11011110', '11000101', '11001100', '11110011', '11111010', '11100001', '11101000',
            '10011111', '10010110', '10001101', '10000100', '10111011', '10110010', '10101001', '10100000',
            '01000111', '01001110', '01010101', '01011100', '01100011', '01101010', '01110001', '01111000',
            '00001111', '00000110', '00011101', '00010100', '00101011', '00100010', '00111001', '00110000',
            '10011010', '10010011', '10001000', '10000001', '10111110', '10110111', '10101100', '10100101',
            '11010010', '11011011', '11000000', '11001001', '11110110', '11111111', '11100100', '11101101',
            '00001010', '00000011', '00011000', '00010001', '00101110', '00100111', '00111100', '00110101',
            '01000010', '01001011', '01010000', '01011001', '01100110', '01101111', '01110100', '01111101',
            '10100001', '10101000', '10110011', '10111010', '10000101', '10001100', '10010111', '10011110',
            '11101001', '11100000', '11111011', '11110010', '11001101', '11000100', '11011111', '11010110',
            '00110001', '00111000', '00100011', '00101010', '00010101', '00011100', '00000111', '00001110',
            '01111001', '01110000', '01101011', '01100010', '01011101', '01010100', '01001111', '01000110']

    # Multiplication by 11
    mul11 = ['00000000', '00001011', '00010110', '00011101', '00101100', '00100111', '00111010', '00110001',
             '01011000', '01010011', '01001110', '01000101', '01110100', '01111111', '01100010', '01101001',
             '10110000', '10111011', '10100110', '10101101', '10011100', '10010111', '10001010', '10000001',
             '11101000', '11100011', '11111110', '11110101', '11000100', '11001111', '11010010', '11011001',
             '01111011', '01110000', '01101101', '01100110', '01010111', '01011100', '01000001', '01001010',
             '00100011', '00101000', '00110101', '00111110', '00001111', '00000100', '00011001', '00010010',
             '11001011', '11000000', '11011101', '11010110', '11100111', '11101100', '11110001', '11111010',
             '10010011', '10011000', '10000101', '10001110', '10111111', '10110100', '10101001', '10100010',
             '11110110', '11111101', '11100000', '11101011', '11011010', '11010001', '11001100', '11000111',
             '10101110', '10100101', '10111000', '10110011', '10000010', '10001001', '10010100', '10011111',
             '01000110', '01001101', '01010000', '01011011', '01101010', '01100001', '01111100', '01110111',
             '00011110', '00010101', '00001000', '00000011', '00110010', '00111001', '00100100', '00101111',
             '10001101', '10000110', '10011011', '10010000', '10100001', '10101010', '10110111', '10111100',
             '11010101', '11011110', '11000011', '11001000', '11111001', '11110010', '11101111', '11100100',
             '00111101', '00110110', '00101011', '00100000', '00010001', '00011010', '00000111', '00001100',
             '01100101', '01101110', '01110011', '01111000', '01001001', '01000010', '01011111', '01010100',
             '11110111', '11111100', '11100001', '11101010', '11011011', '11010000', '11001101', '11000110',
             '10101111', '10100100', '10111001', '10110010', '10000011', '10001000', '10010101', '10011110',
             '01000111', '01001100', '01010001', '01011010', '01101011', '01100000', '01111101', '01110110',
             '00011111', '00010100', '00001001', '00000010', '00110011', '00111000', '00100101', '00101110',
             '10001100', '10000111', '10011010', '10010001', '10100000', '10101011', '10110110', '10111101',
             '11010100', '11011111', '11000010', '11001001', '11111000', '11110011', '11101110', '11100101',
             '00111100', '00110111', '00101010', '00100001', '00010000', '00011011', '00000110', '00001101',
             '01100100', '01101111', '01110010', '01111001', '01001000', '01000011', '01011110', '01010101',
             '00000001', '00001010', '00010111', '00011100', '00101101', '00100110', '00111011', '00110000',
             '01011001', '01010010', '01001111', '01000100', '01110101', '01111110', '01100011', '01101000',
             '10110001', '10111010', '10100111', '10101100', '10011101', '10010110', '10001011', '10000000',
             '11101001', '11100010', '11111111', '11110100', '11000101', '11001110', '11010011', '11011000',
             '01111010', '01110001', '01101100', '01100111', '01010110', '01011101', '01000000', '01001011',
             '00100010', '00101001', '00110100', '00111111', '00001110', '00000101', '00011000', '00010011',
             '11001010', '11000001', '11011100', '11010111', '11100110', '11101101', '11110000', '11111011',
             '10010010', '10011001', '10000100', '10001111', '10111110', '10110101', '10101000', '10100011']

    # Mutiplication by 13
    mul13 = ['00000000', '00001101', '00011010', '00010111', '00110100', '00111001', '00101110', '00100011',
             '01101000', '01100101', '01110010', '01111111', '01011100', '01010001', '01000110', '01001011',
             '11010000', '11011101', '11001010', '11000111', '11100100', '11101001', '11111110', '11110011',
             '10111000', '10110101', '10100010', '10101111', '10001100', '10000001', '10010110', '10011011',
             '10111011', '10110110', '10100001', '10101100', '10001111', '10000010', '10010101', '10011000',
             '11010011', '11011110', '11001001', '11000100', '11100111', '11101010', '11111101', '11110000',
             '01101011', '01100110', '01110001', '01111100', '01011111', '01010010', '01000101', '01001000',
             '00000011', '00001110', '00011001', '00010100', '00110111', '00111010', '00101101', '00100000',
             '01101101', '01100000', '01110111', '01111010', '01011001', '01010100', '01000011', '01001110',
             '00000101', '00001000', '00011111', '00010010', '00110001', '00111100', '00101011', '00100110',
             '10111101', '10110000', '10100111', '10101010', '10001001', '10000100', '10010011', '10011110',
             '11010101', '11011000', '11001111', '11000010', '11100001', '11101100', '11111011', '11110110',
             '11010110', '11011011', '11001100', '11000001', '11100010', '11101111', '11111000', '11110101',
             '10111110', '10110011', '10100100', '10101001', '10001010', '10000111', '10010000', '10011101',
             '00000110', '00001011', '00011100', '00010001', '00110010', '00111111', '00101000', '00100101',
             '01101110', '01100011', '01110100', '01111001', '01011010', '01010111', '01000000', '01001101',
             '11011010', '11010111', '11000000', '11001101', '11101110', '11100011', '11110100', '11111001',
             '10110010', '10111111', '10101000', '10100101', '10000110', '10001011', '10011100', '10010001',
             '00001010', '00000111', '00010000', '00011101', '00111110', '00110011', '00100100', '00101001',
             '01100010', '01101111', '01111000', '01110101', '01010110', '01011011', '01001100', '01000001',
             '01100001', '01101100', '01111011', '01110110', '01010101', '01011000', '01001111', '01000010',
             '00001001', '00000100', '00010011', '00011110', '00111101', '00110000', '00100111', '00101010',
             '10110001', '10111100', '10101011', '10100110', '10000101', '10001000', '10011111', '10010010',
             '11011001', '11010100', '11000011', '11001110', '11101101', '11100000', '11110111', '11111010',
             '10110111', '10111010', '10101101', '10100000', '10000011', '10001110', '10011001', '10010100',
             '11011111', '11010010', '11000101', '11001000', '11101011', '11100110', '11110001', '11111100',
             '01100111', '01101010', '01111101', '01110000', '01010011', '01011110', '01001001', '01000100',
             '00001111', '00000010', '00010101', '00011000', '00111011', '00110110', '00100001', '00101100',
             '00001100', '00000001', '00010110', '00011011', '00111000', '00110101', '00100010', '00101111',
             '01100100', '01101001', '01111110', '01110011', '01010000', '01011101', '01001010', '01000111',
             '11011100', '11010001', '11000110', '11001011', '11101000', '11100101', '11110010', '11111111',
             '10110100', '10111001', '10101110', '10100011', '10000000', '10001101', '10011010', '10010111']

    # Multiplication by 14
    mul14 = ['00000000', '00001110', '00011100', '00010010', '00111000', '00110110', '00100100', '00101010',
             '01110000', '01111110', '01101100', '01100010', '01001000', '01000110', '01010100', '01011010',
             '11100000', '11101110', '11111100', '11110010', '11011000', '11010110', '11000100', '11001010',
             '10010000', '10011110', '10001100', '10000010', '10101000', '10100110', '10110100', '10111010',
             '11011011', '11010101', '11000111', '11001001', '11100011', '11101101', '11111111', '11110001',
             '10101011', '10100101', '10110111', '10111001', '10010011', '10011101', '10001111', '10000001',
             '00111011', '00110101', '00100111', '00101001', '00000011', '00001101', '00011111', '00010001',
             '01001011', '01000101', '01010111', '01011001', '01110011', '01111101', '01101111', '01100001',
             '10101101', '10100011', '10110001', '10111111', '10010101', '10011011', '10001001', '10000111',
             '11011101', '11010011', '11000001', '11001111', '11100101', '11101011', '11111001', '11110111',
             '01001101', '01000011', '01010001', '01011111', '01110101', '01111011', '01101001', '01100111',
             '00111101', '00110011', '00100001', '00101111', '00000101', '00001011', '00011001', '00010111',
             '01110110', '01111000', '01101010', '01100100', '01001110', '01000000', '01010010', '01011100',
             '00000110', '00001000', '00011010', '00010100', '00111110', '00110000', '00100010', '00101100',
             '10010110', '10011000', '10001010', '10000100', '10101110', '10100000', '10110010', '10111100',
             '11100110', '11101000', '11111010', '11110100', '11011110', '11010000', '11000010', '11001100',
             '01000001', '01001111', '01011101', '01010011', '01111001', '01110111', '01100101', '01101011',
             '00110001', '00111111', '00101101', '00100011', '00001001', '00000111', '00010101', '00011011',
             '10100001', '10101111', '10111101', '10110011', '10011001', '10010111', '10000101', '10001011',
             '11010001', '11011111', '11001101', '11000011', '11101001', '11100111', '11110101', '11111011',
             '10011010', '10010100', '10000110', '10001000', '10100010', '10101100', '10111110', '10110000',
             '11101010', '11100100', '11110110', '11111000', '11010010', '11011100', '11001110', '11000000',
             '01111010', '01110100', '01100110', '01101000', '01000010', '01001100', '01011110', '01010000',
             '00001010', '00000100', '00010110', '00011000', '00110010', '00111100', '00101110', '00100000',
             '11101100', '11100010', '11110000', '11111110', '11010100', '11011010', '11001000', '11000110',
             '10011100', '10010010', '10000000', '10001110', '10100100', '10101010', '10111000', '10110110',
             '00001100', '00000010', '00010000', '00011110', '00110100', '00111010', '00101000', '00100110',
             '01111100', '01110010', '01100000', '01101110', '01000100', '01001010', '01011000', '01010110',
             '00110111', '00111001', '00101011', '00100101', '00001111', '00000001', '00010011', '00011101',
             '01000111', '01001001', '01011011', '01010101', '01111111', '01110001', '01100011', '01101101',
             '11010111', '11011001', '11001011', '11000101', '11101111', '11100001', '11110011', '11111101',
             '10100111', '10101001', '10111011', '10110101', '10011111', '10010001', '10000011', '10001101']

    def __init__(self, plainkey):
        """
        This init method takes the plain key and manipulates into a byte array used in encryption and decryption
        :param plainkey: This is the plainkey that the user enters. This object will use this key for all
                         encryption and decryption.
        """
        self.key = self.getkey(plainkey)
        self.key = self.keyexpansion(self.key)

    @staticmethod
    def keyexpansioncore(byte, index):
        """

        :param byte: An array of length 4 with a byte in each index
        :param index: This is an index used during the rcon step
        :return: Returns a modified version of the param byte
        """
        # Rotate Left
        temp = [0, 0, 0, 0]
        temp[0] = byte[1]
        temp[1] = byte[2]
        temp[2] = byte[3]
        temp[3] = byte[0]

        # Substitute using the S-box. Converts the binary to an integer and funds its substitute in the sbox
        temp[0] = AES.sbox[op.bintoint(temp[0])]
        temp[1] = AES.sbox[op.bintoint(temp[1])]
        temp[2] = AES.sbox[op.bintoint(temp[2])]
        temp[3] = AES.sbox[op.bintoint(temp[3])]

        # RCon
        temp[0] = op.bitxor(temp[0], AES.rcon[index])

        return temp

    def keyexpansion(self, inputkey):
        """

        :param inputkey: An array of length 16 with a byte in each index
        :return: This function returns an array of length 176 with a byte in each index, the expanded key
        """
        # Copies the input key to the expanded key
        expandedkey = inputkey

        # Variables
        bytesgenerated = 16  # The original key is 128 bits or 16 bytes which is what we start with
        rconiteration = 1  # Rcon iteration begins at 1
        temp = [0, 0, 0, 0]  # Temporary storage for bytes

        while bytesgenerated < 176:
            # Read the last 4 bytes into the core / temp array
            for j in range(4):
                temp[j] = expandedkey[j + bytesgenerated - 4]

            if bytesgenerated % 16 == 0:
                temp = self.keyexpansioncore(temp, rconiteration)
                rconiteration += 1

            for a in range(4):
                expandedkey.append(op.bitxor(expandedkey[bytesgenerated - 16], temp[a]))
                bytesgenerated += 1

        return expandedkey

    @staticmethod
    def subbytes(state):
        """

        :param state: This is an array of length 16 with 1 byte in each index
        :return: Returns an array with each index of state substituted with it's match in the Rigndael S-box
        """

        newstate = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        for i in range(16):
            integer = op.bintoint(state[i])
            newstate[i] = AES.sbox[integer]

        return newstate

    @staticmethod
    def inv_subbytes(state):
        """

        :param state: This is an array of length 16 with 1 byte in each index
        :return: Returns an array with each index of state substituted with it's match in the Rigndael inverse S-box
        """

        newstate = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        for i in range(16):
            integer = op.bintoint(state[i])
            newstate[i] = AES.inv_sbox[integer]

        return newstate

    @staticmethod
    def shiftrows(state):
        """

        :param state: This is an array of length 16 with 1 byte in each index
        :return: returns the array shifted a specific way.
        """

        """This operation imagines the array of length 16 as a 4x4 grid

        0 4 8 12
        1 5 9 13
        2 6 10 14
        3 6 11 15

        The first row is not rotated.
        The second row is rotated left once.
        The third row is rotated left twice.
        The fourth row is rotated left three times.
        Doing these rotations produces this mapping of the
        original grid to the new grid.
        """

        temp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

        temp[0] = state[0]
        temp[1] = state[5]
        temp[2] = state[10]
        temp[3] = state[15]

        temp[4] = state[4]
        temp[5] = state[9]
        temp[6] = state[14]
        temp[7] = state[3]

        temp[8] = state[8]
        temp[9] = state[13]
        temp[10] = state[2]
        temp[11] = state[7]

        temp[12] = state[12]
        temp[13] = state[1]
        temp[14] = state[6]
        temp[15] = state[11]

        return temp

    @staticmethod
    def inv_shiftrows(state):
        """

        :param state: This is an array of length 16 with 1 byte in each index
        :return: returns the array shifted a specific way.
        """

        """This operation imagines the array of length 16 as a 4x4 grid

        0 4 8 12
        1 5 9 13
        2 6 10 14
        3 6 11 15

        The first row is not rotated.
        The second row is rotated right once.
        The third row is rotated right twice.
        The fourth row is rotated right three times.
        Doing these rotations produces this mapping of the
        original grid to the new grid.

        Notice that the indexes of the arrays are swapped from the shiftrows method
        """

        temp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

        temp[0] = state[0]
        temp[5] = state[1]
        temp[10] = state[2]
        temp[15] = state[3]

        temp[4] = state[4]
        temp[9] = state[5]
        temp[14] = state[6]
        temp[3] = state[7]

        temp[8] = state[8]
        temp[13] = state[9]
        temp[2] = state[10]
        temp[7] = state[11]

        temp[12] = state[12]
        temp[1] = state[13]
        temp[6] = state[14]
        temp[11] = state[15]

        return temp

    @staticmethod
    def mixcolumns(state):
        """

        :param state: An array of length 16 with a byte in each index
        :return: returns an array of length 16 with a byte in each index
        """

        """ 
        To calculate the new array, this step finds every dot product of 2 matrix's. The first matrix is the state
        and the second one is a predetermined one.
        These are the 2 matrix's:

        s s s s     2 3 1 1
        s s s s     1 2 3 1
        s s s s     1 1 2 3
        s s s s     3 1 1 2

        in the new state, p:
        p(0) = (s(0) * 2) + (s(1) * 3) + (s(2) * 1) + (s(2) * 1)
        p(1) = (s(1) * 2) + (s(2) * 3) + (s(3) * 1) + (s(0) * 1)
        ....

        However unlike a regular dot product, addition is XOR because we are treating each byte as a galois field
        GF(2^8). In this case addition is the same as an XOR operation. 

        And instead of regular multiplication, we use a lookup table. Simply, this is to keep the result within 
        byte.
        """

        tmp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

        tmp[0] = op.bitxor(AES.mul2[op.bintoint(state[0])], AES.mul3[op.bintoint(state[1])], state[2], state[3])
        tmp[1] = op.bitxor(AES.mul2[op.bintoint(state[1])], AES.mul3[op.bintoint(state[2])], state[3], state[0])
        tmp[2] = op.bitxor(AES.mul2[op.bintoint(state[2])], AES.mul3[op.bintoint(state[3])], state[0], state[1])
        tmp[3] = op.bitxor(AES.mul2[op.bintoint(state[3])], AES.mul3[op.bintoint(state[0])], state[1], state[2])

        tmp[4] = op.bitxor(AES.mul2[op.bintoint(state[4])], AES.mul3[op.bintoint(state[5])], state[6], state[7])
        tmp[5] = op.bitxor(AES.mul2[op.bintoint(state[5])], AES.mul3[op.bintoint(state[6])], state[7], state[4])
        tmp[6] = op.bitxor(AES.mul2[op.bintoint(state[6])], AES.mul3[op.bintoint(state[7])], state[4], state[5])
        tmp[7] = op.bitxor(AES.mul2[op.bintoint(state[7])], AES.mul3[op.bintoint(state[4])], state[5], state[6])

        tmp[8] = op.bitxor(AES.mul2[op.bintoint(state[8])], AES.mul3[op.bintoint(state[9])], state[10], state[11])
        tmp[9] = op.bitxor(AES.mul2[op.bintoint(state[9])], AES.mul3[op.bintoint(state[10])], state[11], state[8])
        tmp[10] = op.bitxor(AES.mul2[op.bintoint(state[10])], AES.mul3[op.bintoint(state[11])], state[8], state[9])
        tmp[11] = op.bitxor(AES.mul2[op.bintoint(state[11])], AES.mul3[op.bintoint(state[8])], state[9], state[10])

        tmp[12] = op.bitxor(AES.mul2[op.bintoint(state[12])], AES.mul3[op.bintoint(state[13])], state[14],
                            state[15])
        tmp[13] = op.bitxor(AES.mul2[op.bintoint(state[13])], AES.mul3[op.bintoint(state[14])], state[15],
                            state[12])
        tmp[14] = op.bitxor(AES.mul2[op.bintoint(state[14])], AES.mul3[op.bintoint(state[15])], state[12],
                            state[13])
        tmp[15] = op.bitxor(AES.mul2[op.bintoint(state[15])], AES.mul3[op.bintoint(state[12])], state[13],
                            state[14])

        return tmp

    @staticmethod
    def inv_mixcolumns(state):
        """

        :param state: An array of length 16 with a byte in each index
        :return: returns an array of length 16 with a byte in each index
        """

        """ 
        To calculate the new array, this step finds every dot product of 2 matrix's. The first matrix is the state
        and the second one is a predetermined one.
        These are the 2 matrix's:

        s s s s     14 11 13 09
        s s s s     09 14 11 13
        s s s s     13 09 14 11
        s s s s     11 13 09 14

        This is the exact same as regular mixcolumns except the predetermined matrix is different.
        """
        tmp = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

        tmp[0] = op.bitxor(AES.mul14[op.bintoint(state[0])], AES.mul11[op.bintoint(state[1])],
                           AES.mul13[op.bintoint(state[2])], AES.mul9[op.bintoint(state[3])])

        tmp[1] = op.bitxor(AES.mul14[op.bintoint(state[1])], AES.mul11[op.bintoint(state[2])],
                           AES.mul13[op.bintoint(state[3])], AES.mul9[op.bintoint(state[0])])

        tmp[2] = op.bitxor(AES.mul14[op.bintoint(state[2])], AES.mul11[op.bintoint(state[3])],
                           AES.mul13[op.bintoint(state[0])], AES.mul9[op.bintoint(state[1])])

        tmp[3] = op.bitxor(AES.mul14[op.bintoint(state[3])], AES.mul11[op.bintoint(state[0])],
                           AES.mul13[op.bintoint(state[1])], AES.mul9[op.bintoint(state[2])])

        tmp[4] = op.bitxor(AES.mul14[op.bintoint(state[4])], AES.mul11[op.bintoint(state[5])],
                           AES.mul13[op.bintoint(state[6])], AES.mul9[op.bintoint(state[7])])

        tmp[5] = op.bitxor(AES.mul14[op.bintoint(state[5])], AES.mul11[op.bintoint(state[6])],
                           AES.mul13[op.bintoint(state[7])], AES.mul9[op.bintoint(state[4])])

        tmp[6] = op.bitxor(AES.mul14[op.bintoint(state[6])], AES.mul11[op.bintoint(state[7])],
                           AES.mul13[op.bintoint(state[4])], AES.mul9[op.bintoint(state[5])])

        tmp[7] = op.bitxor(AES.mul14[op.bintoint(state[7])], AES.mul11[op.bintoint(state[4])],
                           AES.mul13[op.bintoint(state[5])], AES.mul9[op.bintoint(state[6])])

        tmp[8] = op.bitxor(AES.mul14[op.bintoint(state[8])], AES.mul11[op.bintoint(state[9])],
                           AES.mul13[op.bintoint(state[10])], AES.mul9[op.bintoint(state[11])])

        tmp[9] = op.bitxor(AES.mul14[op.bintoint(state[9])], AES.mul11[op.bintoint(state[10])],
                           AES.mul13[op.bintoint(state[11])], AES.mul9[op.bintoint(state[8])])

        tmp[10] = op.bitxor(AES.mul14[op.bintoint(state[10])], AES.mul11[op.bintoint(state[11])],
                            AES.mul13[op.bintoint(state[8])], AES.mul9[op.bintoint(state[9])])

        tmp[11] = op.bitxor(AES.mul14[op.bintoint(state[11])], AES.mul11[op.bintoint(state[8])],
                            AES.mul13[op.bintoint(state[9])], AES.mul9[op.bintoint(state[10])])

        tmp[12] = op.bitxor(AES.mul14[op.bintoint(state[12])], AES.mul11[op.bintoint(state[13])],
                            AES.mul13[op.bintoint(state[14])], AES.mul9[op.bintoint(state[15])])

        tmp[13] = op.bitxor(AES.mul14[op.bintoint(state[13])], AES.mul11[op.bintoint(state[14])],
                            AES.mul13[op.bintoint(state[15])], AES.mul9[op.bintoint(state[12])])

        tmp[14] = op.bitxor(AES.mul14[op.bintoint(state[14])], AES.mul11[op.bintoint(state[15])],
                            AES.mul13[op.bintoint(state[12])], AES.mul9[op.bintoint(state[13])])

        tmp[15] = op.bitxor(AES.mul14[op.bintoint(state[15])], AES.mul11[op.bintoint(state[12])],
                            AES.mul13[op.bintoint(state[13])], AES.mul9[op.bintoint(state[14])])

        return tmp

    @staticmethod
    def addroundkey(state, roundkey):
        """

        :param state: This is an array of length 16 with 1 byte in each index.
        :param roundkey: This is another array of length 16 with a byte in each index.
        :return: Returns an array with each index of state added with each index roundkey as galois fields.
                 This is the same as the XOR operation.
        """

        newstate = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        for i in range(16):
            newstate[i] = op.bitxor(state[i], roundkey[i])

        return newstate

    @staticmethod
    def getkey(key):
        """

        :param key: A key in plaintext or list of hex values. Length 16
        :return: Returns the key but formatted as an array of length 16 with a byte in each index.

        This function basically returns the key in binary as an array.
        """
        keytype = str(type(key))
        keylength = len(key)
        newkey = []

        if keytype == "<class 'list'>":
            for i in range(16):
                if i < keylength:
                    newkey.append(op.hextobin(key[i]))
                else:
                    newkey.append("00000000")

        elif keytype == "<class 'str'>":
            for i in range(16):
                if i < keylength:
                    newkey.append(op.stringtobin(key[i]))
                else:
                    newkey.append("00000000")
        else:
            print("Key Type is Invalid. Must be string or list of hex valus. eg. ['4f', '2a', '0b'.....]")
            print("Key used will be all null")
            for i in range(16):
                newkey.append("00000000")

        return newkey

    def encrypt(self, message, message_type, output_type="hex"):
        """
        :param message: The message to be encrypted. Either a file or string
        :param message_type: The type of the message. 'string' or 'file'
        :param output_type: The type of the output. 'hex' or 'string' or 'bytes'
        :return: Returns the encrypted message
        """

        numofrounds = 9
        proceed = True  # This variable will monitor if all the parameters are correct.

        # ------------This section gets a byte array from the message------------------------------------
        # Get the byte array
        if message_type == "file":
            message_bytes = op.getbytearray(message)

        elif message_type == "string":
            message_bytes = []
            for i in range(len(message)):
                message_bytes.append(op.inttobin(ord(message[i])))
        else:
            print("MESSSAGE TYPE IS INVALID. CHOOSE 'string' OR 'file'.")
            proceed = False

        # Check to make sure the message is a string
        if str(type(message)) != "<class 'str'>":
            proceed = False
            print("The message must be a string")

        # This section initializes the encrypted message as either a list or a string
        # depending on the output type
        if output_type == "hex" or output_type == "string":
            encryptedmessage = ""
        elif output_type == "bytes":
            encryptedmessage = []
        else:
            proceed = False
            print("OUTPUT TYPE IS INVALID. CHOOSE 'hex' or 'string' or 'bytes'.")

        # --------------------------------------------------------------------------------------------------------------
        if proceed:
            # Pad the byte array
            while len(message_bytes) % 16 != 0:
                message_bytes.append("00000000")

            loops = len(message_bytes) // 16

            for k in range(loops):
                # --------THIS SECTION DEALS THIS GETTING THE 16 BYTE ARRAY CALLED THE STATE FROM THE MESSAGE------------
                # Initialize the state and get the necessary block of 16 characters
                state = message_bytes[k * 16: (k + 1) * 16]
                # --------------NOW WE HAVE OUR STATE AND CAN START ENCRYPTION-------------------------------------------

                # Initial Round
                state = self.addroundkey(state, self.key[0:16])  # Whitening / Add round key

                # Main Rounds
                for icounter in range(numofrounds):
                    state = self.subbytes(state)
                    state = self.shiftrows(state)
                    state = self.mixcolumns(state)
                    state = self.addroundkey(state, self.key[16 * (icounter + 1): 16 * (icounter + 2)])

                # Final Round
                state = self.subbytes(state)
                state = self.shiftrows(state)
                state = self.addroundkey(state, self.key[160:])

                # -------------------------------------------------------------------------------------------------------
                # AT THIS POINT, THE ENCRYPTION IS DONE.
                # THE FOLLOWEING CODE IS JUST HOW THE ENCRYPTED MESSAGE SHOULD BE OUTPUTTED.

                if output_type == "hex":
                    for i in range(16):
                        state[i] = op.bintohex(state[i])[6:]
                        encryptedmessage += (state[i])

                elif output_type == "string":
                    for i in range(16):
                        state[i] = op.bintostring(state[i])
                        encryptedmessage += (state[i])

                elif output_type == "bytes":
                    encryptedmessage += state

                else:
                    print("INVALID OUTPUT TYPE. Choose 'hex' 'string' 'bytes'")

            return encryptedmessage

    def decrypt(self, message, message_type, output_type="string"):
        """
        :param message: The message to be decrypted
        :param message_type: The type of the encrypted message. 'hex' or 'string' or 'bytes' or 'file'
        :param output_type: The type of the output. 'string' or 'bytes'
        :return:  The orginal message.
        """

        numofrounds = 9
        proceed = True  # This variable will monitor if all the parameters are correct.

        # ----------THIS SECTION CHECKS ALL PARAMETERS BEFORE STARTING THE DECRYPTON--------------
        # ------------This section gets a byte array from the message-----------------------------------
        # Get the byte array
        message_bytes = []

        if message_type == "hex":
            for i in range(len(message) // 2):
                message_bytes.append(op.hextobin(message[(i * 2):(i * 2) + 2]))

        elif message_type == "string":
            for i in range(len(message)):
                message_bytes.append(op.inttobin(ord(message[i])))

        elif message_type == "bytes":
            message_bytes = message

        elif message_type == "file":
            message_bytes = op.getbytearray(message)

        else:
            print("MESSSAGE TYPE IS INVALID. CHOOSE 'hex' or 'string' or 'bytes' or 'file'.")
            proceed = False

        # --------------

        if len(message_bytes) % 16 != 0:
            proceed = False
            print("The bytes in message parameter is of the wrong size")

        # Check to make sure the message is a string or bytearray
        if str(type(message)) != "<class 'str'>" and str(type(message)) != "<class 'list'>":
            proceed = False
            print("The message must be a string or a bytearray.")

        # This section initializes the decrypted message as either a list or a string
        # depending on the output type
        if output_type == "string":
            decryptedmessage = ""
        elif output_type == "bytes":
            decryptedmessage = []
        else:
            proceed = False
            print("OUTPUT TYPE IS INVALID. CHOOSE 'string' or 'bytes'.")

        if proceed:
            loops = len(message_bytes) // 16

            for k in range(loops):
                # Initialize the state and get the necessary block of 16 characters
                # Here, we have the bytes and we just have to write the current block of 16 to the state
                state = message_bytes[k * 16:(k + 1) * 16]

                # Now we have our key and state and we can start the decryption

                # First step is reverse the final round
                state = self.addroundkey(state, self.key[160:])
                state = self.inv_shiftrows(state)
                state = self.inv_subbytes(state)

                # Reverse the main rounds
                for icounter in range(numofrounds):
                    state = self.addroundkey(state, self.key[16 * (9 - icounter): 16 * (10 - icounter)])
                    state = self.inv_mixcolumns(state)
                    state = self.inv_shiftrows(state)
                    state = self.inv_subbytes(state)

                # Reverse the initial round
                state = self.addroundkey(state, self.key[0:16])

                if output_type == "string":
                    for icounter in range(16):
                        decryptedmessage += chr(op.bintoint(state[icounter]))
                else:
                    decryptedmessage += state

            return decryptedmessage

    def communicate(self, sender=False, IP='0.0.0.0'):
        """
        This is the method to call when the user wants to communicate between 2 computers
        :param sender: If this computer sends first, set this value to True
        :param IP: If sender is True, then the IP of the receiving computer must be inserted here
        """
        global socketHolder
        if sender:
            socketHolder.connect((IP, 54321))
            print("connected")
        else:
            socketHolder.bind(('0.0.0.0', 54321))
            socketHolder.listen()
            connection, address = socketHolder.accept()
            socketHolder = connection

        a = threading.Thread(target=self.sends)
        b = threading.Thread(target=self.recv)
        a.start()
        b.start()

    def sends(self):
        global socketHolder  # call variable as global
        while True:
            msg = input("")  # placeholder for a way fof getting input
            msg = self.encrypt(msg, "string", "string")
            socketHolder.send(msg.encode(encoding='utf-8', errors='ignore'))  # sends input(add your encryption here)

    def recv(self):
        global socketHolder  # call variable as global
        while True:
            data = socketHolder.recv(4096).decode(encoding='utf-8', errors='strict')  # recieves data from connection
            print(self.decrypt(data, "string", "string"))


class SHA256:
    # --------Unchanging Constants-------
    # these are constants used in the calculations
    # The list is available on wikipedia but must be in binary for the calculations
    constants = ['01000010100010100010111110011000', '01110001001101110100010010010001',
                 '10110101110000001111101111001111',
                 '11101001101101011101101110100101', '00111001010101101100001001011011',
                 '01011001111100010001000111110001',
                 '10010010001111111000001010100100', '10101011000111000101111011010101',
                 '11011000000001111010101010011000',
                 '00010010100000110101101100000001', '00100100001100011000010110111110',
                 '01010101000011000111110111000011',
                 '01110010101111100101110101110100', '10000000110111101011000111111110',
                 '10011011110111000000011010100111',
                 '11000001100110111111000101110100', '11100100100110110110100111000001',
                 '11101111101111100100011110000110',
                 '00001111110000011001110111000110', '00100100000011001010000111001100',
                 '00101101111010010010110001101111',
                 '01001010011101001000010010101010', '01011100101100001010100111011100',
                 '01110110111110011000100011011010',
                 '10011000001111100101000101010010', '10101000001100011100011001101101',
                 '10110000000000110010011111001000',
                 '10111111010110010111111111000111', '11000110111000000000101111110011',
                 '11010101101001111001000101000111',
                 '00000110110010100110001101010001', '00010100001010010010100101100111',
                 '00100111101101110000101010000101',
                 '00101110000110110010000100111000', '01001101001011000110110111111100',
                 '01010011001110000000110100010011',
                 '01100101000010100111001101010100', '01110110011010100000101010111011',
                 '10000001110000101100100100101110',
                 '10010010011100100010110010000101', '10100010101111111110100010100001',
                 '10101000000110100110011001001011',
                 '11000010010010111000101101110000', '11000111011011000101000110100011',
                 '11010001100100101110100000011001',
                 '11010110100110010000011000100100', '11110100000011100011010110000101',
                 '00010000011010101010000001110000',
                 '00011001101001001100000100010110', '00011110001101110110110000001000',
                 '00100111010010000111011101001100',
                 '00110100101100001011110010110101', '00111001000111000000110010110011',
                 '01001110110110001010101001001010',
                 '01011011100111001100101001001111', '01101000001011100110111111110011',
                 '01110100100011111000001011101110',
                 '01111000101001010110001101101111', '10000100110010000111100000010100',
                 '10001100110001110000001000001000',
                 '10010000101111101111111111111010', '10100100010100000110110011101011',
                 '10111110111110011010001111110111',
                 '11000110011100010111100011110010']

    @staticmethod
    def create_salt():
        """
        This method simply uses a random number generator to get a random salt
        :return: A random string
        """
        saltval = op.bintohex(op.inttobin(random.getrandbits(128)))
        return saltval

    @staticmethod
    def hash(message, messagetype, salt=""):
        """
        This method hashes any string.
        :param message: The messaee that needs to be hashed
        :param salt: A salt is appended to a message, it is optional whether you want to include a salt while hashing
        :param messagetype: The type of message. 'string' or 'file'
        :return: The hashed message
        """
        # ---------Initial Hash Values-------
        # these hash values change for each 512 bit chunk, and start as the following
        h0 = "01101010000010011110011001100111"
        h1 = "10111011011001111010111010000101"
        h2 = "00111100011011101111001101110010"
        h3 = "10100101010011111111010100111010"
        h4 = "01010001000011100101001001111111"
        h5 = "10011011000001010110100010001100"
        h6 = "00011111100000111101100110101011"
        h7 = "01011011111000001100110100011001"

        # -----------------Padding-----------------
        # This sections initializes the first 16 "words". Each "word" is 32 bits.

        # gets the message input and turns it into binary
        if messagetype == "string":
            paddedmessage = op.stringtobin(message + salt)
        elif messagetype == "file":
            file_array = op.getbytearray(message)
            paddedmessage = ""
            for icounter in range(len(file_array)):
                paddedmessage += file_array[icounter]

        else:
            print("Message Type Invalid. Must be 'string' or 'file' defaulted to string")
            paddedmessage = op.stringtobin(message + salt)

        # takes the length of the padded message, converts it into bits, and stores it in bitsinmessage
        bitsinmessage = op.inttobin(len(paddedmessage))

        # Pad the bits in message to be of length 64
        while len(bitsinmessage) < 64:
            bitsinmessage = "0" + bitsinmessage

        # adds a one to the end of the padded message
        paddedmessage += "1"

        # adds 0's to make the length of  (paddedmessage - the length of bitsinmessage) a multiple of 512
        while (len(paddedmessage) + len(bitsinmessage)) % 512 != 0:
            paddedmessage += "0"

        # adds bits in messsage to the end of padded message
        paddedmessage += bitsinmessage

        # creates a variable called fullmessage which is the padded message and is not affected
        fullmessage = paddedmessage

        # for each 512-bit chunk of full message (represented my paddedmessage)the following happens
        for z in range(len(paddedmessage) // 512):
            # words is a list that stores the 32 bit 'words'
            words = []
            # takes the chunk and seperates it into 16, 32 bit words
            paddedmessage = fullmessage[512 * z: 512 * (z + 1)]
            for i in range(16):
                words.append(paddedmessage[32 * i: 32 * (i + 1)])

            # ----------Creating the 64 words from the first 16-------

            # creates the other 48 words using the first 16
            for i in range(16, 64):

                s0 = op.bitxor(op.bitxor(op.rightrotate(words[i - 15], 7), op.rightrotate(words[i - 15], 18)),
                               op.rightshift(words[i - 15], 3))
                s1 = op.bitxor(op.bitxor(op.rightrotate(words[i - 2], 17), op.rightrotate(words[i - 2], 19)),
                               op.rightshift(words[i - 2], 10))

                sum1 = op.bitadd(words[i - 16], s0)
                sum2 = op.bitadd(words[i - 7], s1)
                total = op.bitadd(sum1, sum2)
                while len(total) < 32:
                    total = "0" + total

                # Only take the first 32 bits, starting from the right by chopping of the first 8 bytes
                # if its bigger
                if len(total) > 32:
                    total = total[len(total) - 32:]

                # adds the new word into the list of words
                words.append(total)

            # -----Initialize variables to initial hash values, as they will change-----
            a = h0
            b = h1
            c = h2
            d = h3
            e = h4
            f = h5
            g = h6
            h = h7

            # Checks to make sure the bit length of any variable doesn't exceed 32
            for i in range(64):
                if len(a) > 32:
                    a = a[len(a) - 32:]

                if len(b) > 32:
                    b = b[len(b) - 32:]

                if len(c) > 32:
                    c = c[len(c) - 32:]

                if len(d) > 32:
                    d = d[len(d) - 32:]

                if len(e) > 32:
                    e = e[len(e) - 32:]

                if len(f) > 32:
                    f = f[len(f) - 32:]

                if len(g) > 32:
                    g = g[len(g) - 32:]

                if len(h) > 32:
                    h = h[len(h) - 32:]

                # The Main Algorithm
                S1 = op.bitxor(op.rightrotate(e, 6), op.rightrotate(e, 11), op.rightrotate(e, 25))

                # Choose Function
                ch = op.bitxor(op.bitand(e, f), op.bitand(op.bitnot(e), g))

                temp1 = op.bitadd(h, S1, ch, SHA256.constants[i], words[i])
                S0 = op.bitxor(op.rightrotate(a, 2), op.rightrotate(a, 13), op.rightrotate(a, 22))
                # The majority function
                maj = op.bitxor(op.bitand(a, b), op.bitand(a, c), op.bitand(b, c))

                temp2 = op.bitadd(S0, maj)

                # Variable Swaps and additions
                h = g
                g = f
                f = e
                e = op.bitadd(d, temp1)
                d = c
                c = b
                b = a
                a = op.bitadd(temp1, temp2)

            # Add each letter to its corresponding hash value
            h0 = op.bitadd(h0, a)
            h1 = op.bitadd(h1, b)
            h2 = op.bitadd(h2, c)
            h3 = op.bitadd(h3, d)
            h4 = op.bitadd(h4, e)
            h5 = op.bitadd(h5, f)
            h6 = op.bitadd(h6, g)
            h7 = op.bitadd(h7, h)

        # Convert to Hex, then to a string.
        h0 = str(op.bintohex(h0))
        h1 = str(op.bintohex(h1))
        h2 = str(op.bintohex(h2))
        h3 = str(op.bintohex(h3))
        h4 = str(op.bintohex(h4))
        h5 = str(op.bintohex(h5))
        h6 = str(op.bintohex(h6))
        h7 = str(op.bintohex(h7))

        # Cut off if the length of the hex string is greater than 8
        if len(h0) > 8:
            h0 = h0[len(h0) - 8:]
        if len(h1) > 8:
            h1 = h1[len(h1) - 8:]
        if len(h2) > 8:
            h2 = h2[len(h2) - 8:]
        if len(h3) > 8:
            h3 = h3[len(h3) - 8:]
        if len(h4) > 8:
            h4 = h4[len(h4) - 8:]
        if len(h5) > 8:
            h5 = h5[len(h5) - 8:]
        if len(h6) > 8:
            h6 = h6[len(h6) - 8:]
        if len(h7) > 8:
            h7 = h7[len(h7) - 8:]

        # Concatenate the strings
        finalhash = h0 + h1 + h2 + h3 + h4 + h5 + h6 + h7
        return finalhash

    @staticmethod
    def send(serverIP, message):
        """
        :param serverIP: This is the IP of the computer you want to send the message to.
        :param message: The message to be sent to the computer.
        """
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sender:
            sender.connect((serverIP, 5432))
            sender.send(bytes(message, encoding='utf-8'))

        time.sleep(0.2)

    @staticmethod
    def server_recv():
        """
        This initializes this computer as a server which can receive messages
        from anyone using the send function above.
        """
        while True:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
                server.bind(("0.0.0.0", 5432))
                server.listen()
                connection, address = server.accept()
                server.setblocking(False)
                with connection:
                    print(address[0], "connected")
                    print(connection.recv(4096).decode(encoding='utf-8', errors='ignore'))


class RSA:
    # (one line function) for modular multiplicative inverse of a and n, found on code signal, made by Yousef Hadder
    MMI = lambda A, n, s=1, t=0, N=0: (n < 2 and t % N or RSA.MMI(n, A % n, t, s - A // n * t, N or n), -1)[n < 1]
    # credit : Yousef Hadder, Code signal
    '''Sets up the a class for an instance of rsa communication'''

    def __init__(self):
        '''
        This function initializes an RSA object, meaning all related numbers are generated, as are the keys
        The code follows this algorithm to generate the keys, and the attributes are aptly named:
        p and q are two prime numbers, generated randomly (not in a cryptographically secure way) from a list
        p and q are guarenteed to be different before continuing
        n, the modulus for both of the future keys is generated by p and q's multiplication
        the totient, number of coprimes of p and q from 1 to n found using the LCM p-1 and q-1
        e, the first part of the encryption key is generated using a number coprime with the totient and n less than the totient
        this is circumvented using
        d is generated as the modular multiplicative inverse of e and the totient
        '''
        self.numlist = [199, 211, 223, 227, 229, 233, 239, 241, 251, 257,
                        263, 269, 271, 277, 281, 283, 293, 307, 311, 313]

        # The list of primes above is used to generate prme numbers to be used in the code
        self.p = self.numlist[random.randint(0, len(self.numlist) - 1)]  # p is generated randomly
        self.q = self.numlist[random.randint(0, len(self.numlist) - 1)]  # q is generated randomly
        while self.q == self.p:  # as p and q must not be equal, this runs the random selsection until different values selected
            self.q = self.numlist[random.randint(0, len(self.numlist) - 1)]
        self.n = self.p * self.q  # n is genrated as the product of p and q
        self.totient = (self.p - 1) * (self.q - 1) // math.gcd(self.p - 1,
                                                               self.q - 1)  # totient(n), the number of coprimes with p and q from 1 to n is genterated
        self.numlist2 = []
        for icounter in range(2, self.totient):  # counts to one past upper limit (pre conditional)
            bprime = True  # predefines each number as prime, to be disproven
            ichecker = 2  # starts checker at 2, as that is the smallest prime
            while bprime != False and ichecker < int(
                    float(icounter ** (1 / 2) + 1)):  # allows exit when proven composite or after all test cases
                if icounter % ichecker == 0:  # checks if the mod of any number gives 0 indicating non prime
                    bprime = False  # sets prime value to false, so it is not counted in later commands
                else:
                    ichecker += 1  # ichecker moves onto next test number
            if bprime == True and self.totient % icounter != 0:
                self.numlist2.append(icounter)  # appends number
        self.e = self.numlist2[random.randint(0, len(self.numlist2))]

        self.d = RSA.MMI(self.e, self.totient)  # implementation of lambda

        self.encryptkey = (self.e, self.n)  # generates tuple to act as lock
        self.decryptkey = (self.d, self.n)  # generates tuple to act as key

    @staticmethod
    def encrypt(k1, k2, message):
        '''
        :param k1: exponential part of key
        :param k2: modulus part of key
        :param message: message to encrypt
        :return: string of numbers seperated by
        '''
        encrypted = []
        for letter in message:
            encrypted.append((ord(letter)) ** k1 % k2)
        return str(' '.join(str(n) for n in encrypted))

    def decrypt(self, emessage):  # takes an encrypted message
        '''
        :param emessage: This is an encrypted message, encrypted by the respective method in this very class or the staticmethod 'send'
        :return: The decrypted emessage as a string using the keys for the instance of conversation
        '''
        emessage = emessage.split()
        decrypted = []  # creates an empty list
        for n in (emessage):
            decrypted.append(
                (int(n) ** (self.decryptkey[0])) % (self.decryptkey[1]))  # Decrypts ASCII value (decrypted) to list
        decrypted = "".join(str(chr(n)) for n in
                            decrypted)  # creates string from list of decrypted values and turns each ASCII to a character
        return decrypted

    def server(self):
        '''
        Creates a single client server that recieves a meaningless message, sends the public key to the client, and
        recieves an encrypted message.
        :return: The dercypted message using the decrypt method found in this class
        '''
        incoming = []  # creates an empty list to recieve the incoming encrypted characters
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:  # creates a "setup" server
            server.bind(("0.0.0.0", 15432))  # binds the socket to listen on all available networks
            server.listen()  # listens for a client to connect
            connection, address = server.accept()  # recieves two return values of accept() the latter will be used to send keys
            server.close()  # closes the connection establishing code
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:  # sends the key as generated by init()
            server.connect((address[0], 6433))  # uses pre-established address variable to get server IP
            server.send(
                bytes((str(self.encryptkey[0])) + " " + (str(self.encryptkey[1])), encoding='utf-8'))  # sends key
        with socket.socket(socket.AF_INET,
                           socket.SOCK_STREAM) as server:  # creates  the connection to recieve the message
            server.bind(("0.0.0.0", 15444))
            server.listen()  # listens on all networks
            conn, addr = server.accept()  # recieves two input from accept()
            with conn:
                length = int(conn.recv(4096).decode(encoding='utf-8', errors='strict'))
                for n in range(length):
                    incoming.append(int(conn.recv(4096).decode(encoding='utf-8', errors='strict')))
                print(incoming)
                return (self.decrypt(incoming))

    @staticmethod
    def RSA_send(IP):
        '''
        This program sends an encrypted message to a specified ip
        :param IP: An Ip to send an encrypted message to
        :return: none
        '''
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
            server.connect((IP, 15432))  # connects to the computer
            server.send(bytes("bridgebuilder", encoding='utf-8'))  # sends a meanngless message to establish connection
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
            server.bind(("0.0.0.0", 6433))  # binds server to recieve keys
            server.listen()
            connection, address = server.accept()
            with connection:
                key = (connection.recv(4096).decode(encoding='utf-8', errors='ignore')).split(
                    " ")  # splits message formatted by server method
                key0 = int(key[0])
                key1 = int(key[1])
            server.close()
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sender:
                time.sleep(2)  # waits for server to start listening before connectiong
                sender.connect((IP, 15444))  # connects to other device
                message = input("Send:")  # recieves a message to send
                sender.send(bytes(str(len(message)),
                                  encoding='utf-8'))  # sends length of message for other device to recieve that many times
                for n in message:  # runs for loop for length of message
                    sender.send(bytes((str(((ord(n)) ** key0) % key1)),
                                      encoding='utf-8'))  # sends each letter of message with delay
                    time.sleep(0.05)
                sender.close()


class TripleDES:
    # Initialize all lookup tables used for encryption and decryption
    ColumnNumberTables = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
                           0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
                           4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
                           15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],

                          [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
                           3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
                           0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
                           13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],

                          [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
                           13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
                           13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
                           1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],

                          [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
                           13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
                           10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
                           3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],

                          [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
                           14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
                           4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
                           11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],

                          [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
                           10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
                           9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
                           4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],

                          [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
                           13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
                           1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
                           6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],

                          [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
                           1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
                           7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
                           2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]

    # a lookup table for initial permutation
    InitialPerm = [58, 50, 42, 34, 26, 18, 10, 2,
                   60, 52, 44, 36, 28, 20, 12, 4,
                   62, 54, 46, 38, 30, 22, 14, 6,
                   64, 56, 48, 40, 32, 24, 16, 8,
                   57, 49, 41, 33, 25, 17, 9, 1,
                   59, 51, 43, 35, 27, 19, 11, 3,
                   61, 53, 45, 37, 29, 21, 13, 5,
                   63, 55, 47, 39, 31, 23, 15, 7]

    # a lookup table for expansion bit
    Expansionbit = [32, 1, 2, 3, 4, 5,
                    4, 5, 6, 7, 8, 9,
                    8, 9, 10, 11, 12, 13,
                    12, 13, 14, 15, 16, 17,
                    16, 17, 18, 19, 20, 21,
                    20, 21, 22, 23, 24, 25,
                    24, 25, 26, 27, 28, 29,
                    28, 29, 30, 31, 32, 1]

    # a lookup table for second permutation
    SecondPerm = [16, 7, 20, 21,
                  29, 12, 28, 17,
                  1, 15, 23, 26,
                  5, 18, 31, 10,
                  2, 8, 24, 14,
                  32, 27, 3, 9,
                  19, 13, 30, 6,
                  22, 11, 4, 25]

    # a lookup table for the final permutation
    Finalperm = [40, 8, 48, 16, 56, 24, 64, 32,
                 39, 7, 47, 15, 55, 23, 63, 31,
                 38, 6, 46, 14, 54, 22, 62, 30,
                 37, 5, 45, 13, 53, 21, 61, 29,
                 36, 4, 44, 12, 52, 20, 60, 28,
                 35, 3, 43, 11, 51, 19, 59, 27,
                 34, 2, 42, 10, 50, 18, 58, 26,
                 33, 1, 41, 9, 49, 17, 57, 25]

    # Look up table for Permuted Choice 1
    PC_1 = [57, 49, 41, 33, 25, 17, 9, 1,
            58, 50, 42, 34, 26, 18, 10, 2,
            59, 51, 43, 35, 27, 19, 11, 3,
            60, 52, 44, 36, 63, 55, 47, 39,
            31, 23, 15, 7, 62, 54, 46, 38,
            30, 22, 14, 6, 61, 53, 45, 37,
            29, 21, 13, 5, 28, 20, 12, 4]

    # Look up table for Permuted Choice 2
    PC_2 = [14, 17, 11, 24, 1, 5,
            3, 28, 15, 6, 21, 10,
            23, 19, 12, 4, 26, 8,
            16, 7, 27, 20, 13, 2,
            41, 52, 31, 37, 47, 55,
            30, 40, 51, 45, 33, 48,
            44, 49, 39, 56, 34, 53,
            46, 42, 50, 36, 29, 32]

    # List for the changing iterations for rotating
    iteration = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]

    def __init__(self, plainkey):
        self.key = self.keyCreator(plainkey)

    @staticmethod
    def Perm(listinput, inputmessage):

        """
        :param listinput: is the table you want to permute the input message according to
        :param inputmessage: is the message that you want to permute
        :return: returns the permuted message
        """

        # initalizes a variable called finalmessage
        finalmessage = ""
        listlength = len(listinput)

        for index in range(listlength):
            finalmessage += inputmessage[listinput[index] - 1]

        return finalmessage

    @staticmethod
    def Sbox(inputmessage):

        """
        :param inputmessage: the message that you want to permute
        :return: returns the permuted message
        """

        # the tables that are used to get the output message for every iteration

        finalmessage = ""

        for boxnum in range(8):  # Substitution Box

            # takes 6 bits at a time from the message
            sixbits = inputmessage[boxnum * 6: (boxnum + 1) * 6]

            # the row is the first but and the last bit of the sixbits
            row = sixbits[0] + sixbits[5]

            # the column is the middle 4
            columns = sixbits[1] + sixbits[2] + sixbits[3] + sixbits[4]

            # converts the row and column to an integer
            row = op.bintoint(row)
            columns = op.bintoint(columns)

            # finds a value using the current s-box to
            columnrowindex = (row * 16) + columns

            # makes temp equal the the corresponding number on the table
            temp = op.inttobin(TripleDES.ColumnNumberTables[boxnum][columnrowindex])[4:]

            # adds the temp message to finalmesssage
            finalmessage += temp
        return finalmessage

    def DESencrypt(self, input, Keys, round):
        """
        :param input: plain text message
        :param Keys: which keys you are using
        :param round: which round you need to use.
        :return:
        """
        final = ''

        input = op.stringtobin(input)

        # pads the message with zeros after it to make it a multiple of 64
        while len(input) % 64 != 0:
            input += "0"

        # finds out how many blocks of 64 there are
        blocks = len(input) // 64

        # runs for every block
        for index in range(blocks):

            # gets the 64 bit chunk from the message
            message = input[index * 64: (index + 1) * 64]

            # does the initial permutation
            message = self.Perm(TripleDES.InitialPerm, message)

            # splits the message into left and right
            MessageLeft = message[0:32]
            MessageRight = message[32:64]

            # runs for each key
            for subkey in range(16):
                righttemp = ''

                # lefttemp becomes message right we do this because messageLeft has to equal
                # message right, but we use MessageRight in another step so lefttemp is necessary
                lefttemp = MessageRight

                # expands righttemp
                righttemp = self.Perm(TripleDES.Expansionbit, MessageRight)

                righttemp = op.bitxor(Keys[round][subkey], righttemp)  # xors the subkey and right temp

                while len(righttemp) < 48:
                    righttemp = "0" + righttemp  # pads the right temp until it reaches the desired length

                righttemp = self.Sbox(righttemp)  # runs sbox function on righttemp

                righttemp = self.Perm(TripleDES.SecondPerm, righttemp)  # runs perm function on right temp

                MessageRight = op.bitxor(MessageLeft, righttemp)  # xors messageleft with message right

                while len(MessageRight) < 32:
                    MessageRight = "0" + MessageRight  # pads the message until it reaches 32 bits

                MessageLeft = lefttemp

            temp = ''

            message = (MessageRight + MessageLeft)  # combines the two halves of the message

            for g in range(64):
                temp += message[TripleDES.Finalperm[g] - 1]  # final permutation

            final += temp

        return op.bintostring(final)  # returns string of encrypted message.

    def DESdecrypt(self, input, Keys, round):
        """
        :param input: encrypted message
        :param Keys: which keys to use
        :param round: which round you need to use
        :return:
        """

        final = ''

        input = op.stringtobin(input)

        # pads the message with zeros after it to make it a multiple of 64
        while len(input) % 64 != 0:
            input += "0"

        # finds out how many blocks of 64 there are
        blocks = len(input) // 64

        # runs for every block
        for index in range(blocks):

            # gets the 64 bit chunk from the message
            message = input[index * 64: (index + 1) * 64]

            # does the initial permutation
            message = self.Perm(TripleDES.InitialPerm, message)

            # splits the message into left and right
            MessageLeft = message[0:32]
            MessageRight = message[32:64]

            # runs for each key
            for subkey in range(16):
                righttemp = ''

                # lefttemp becomes message right we do this because messageLeft has to equal
                # message right, but we use MessageRight in another step so lefttemp is necessary
                lefttemp = MessageRight

                # expands righttemp
                righttemp = self.Perm(TripleDES.Expansionbit, MessageRight)

                righttemp = op.bitxor(Keys[round][15 - subkey],
                                      righttemp)  # XOR the keys in inverse order with right temp

                while len(
                        righttemp) < 48:  # while xor-ing the subkey and righttemp, the length of the final message may be lower than 48 due to no padding from the function
                    righttemp = "0" + righttemp

                righttemp = self.Sbox(righttemp)  # runs the sbox function on right temp

                righttemp = self.Perm(TripleDES.SecondPerm, righttemp)  # run perm fucntion on right temp

                MessageRight = op.bitxor(MessageLeft, righttemp)  # xor the message left and right temp

                while len(MessageRight) < 32:
                    MessageRight = "0" + MessageRight  # the xor may need to be padded, as the function itself does not include it.

                MessageLeft = lefttemp  # message left is given the value of lefttemp

            temp = ''

            message = (MessageRight + MessageLeft)  # combines the two messages

            for g in range(64):
                temp += message[TripleDES.Finalperm[g] - 1]  # does the final permutaion

            final += temp

        return op.bintostring(final)  # function returns the string of the final decrypted message

    def encrypt(self, message, messagetype, outputtype="hex"):
        """
        :param message: inital message or file to be encrypted
        :param messagetype: type of the message 'file' or 'string'.
        :param outputtype: Output type is one of the following:  'string' 'hex(default)' 'bytes'
        :return:
        """
        stringmessage = ""
        if messagetype == "string":  # formats message to a string
            stringmessage = message

        elif messagetype == "file":
            bytesmessage = op.getbytearray(message)
            for i in range(len(bytesmessage)):  # formats message as a file
                stringmessage += op.bintostring(bytesmessage[i])

        else:
            print("Message type invalid. Deafulted to string")
            stringmessage = message  # defaults message to a string

        encryptedmessage = self.DESencrypt(self.DESdecrypt(self.DESencrypt(stringmessage, self.key, 0), self.key, 1),
                                           self.key, 2)

        if outputtype == "string":  # formats output to hex
            pass

        elif outputtype == "hex":
            encryptedmessage = op.bintohex(op.stringtobin(encryptedmessage))  # formats output to hex
            return encryptedmessage

        elif outputtype == "bytes":
            temp = []
            for i in range(len(encryptedmessage)):
                temp.append(op.stringtobin(encryptedmessage[i]))  # formats message to binary

            encryptedmessage = temp

        return encryptedmessage

    def decrypt(self, message, messagetype, outputtype="hex"):
        """
        :param message: encrypted message
        :param messagetype: it can be 'string' , 'hex', 'bytes', or 'file'
        :param outputtype: it can be 'string', 'bytes'
        :return:
        """
        if messagetype == "string":
            encryptedmessage = message  # formats message to string

        elif messagetype == "hex":
            encryptedmessage = op.bintostring(op.hextobin(message))

        elif messagetype == "bytes":
            encryptedmessage = ""  # formats message to binary
            for i in range(len(message)):
                encryptedmessage += op.bintostring(message[i])

        elif messagetype == "file":
            bytesmessage = op.getbytearray(message)
            encryptedmessage = ""  # formats message to file
            for i in range(len(bytesmessage)):
                encryptedmessage += op.bintostring(bytesmessage[i])

        else:
            print("Message Type Invalid. Defaulted to string")
            encryptedmessage = message

        decryptedmessage = self.DESdecrypt(self.DESencrypt(self.DESdecrypt(encryptedmessage, self.key, 2), self.key, 1),
                                           self.key, 0)

        if outputtype == "string":
            pass

        elif outputtype == "bytes":
            temp = []
            for i in range(len(decryptedmessage)):
                temp.append(op.stringtobin(decryptedmessage[i]))

            decryptedmessage = temp

        else:
            print("Output Type Invalid. Defaulted to string")

        return decryptedmessage

    @staticmethod
    def keyCreator(plainkey):
        """
        :param plainkey: requires a plain-text key of max 24 characters
        """
        plainkey = op.stringtobin(plainkey)  # changes the key to bits

        while len(plainkey) < 192:  # Pads the bits with zeros
            plainkey += "0"

        Keys = [[], [], []]  # Initalizes the final list of the three keys

        for n in range(3):  # seperates the 192 bits into three chunks

            key = plainkey[n * 64: (n + 1) * 64]
            temp = ""
            lkey = ""
            rkey = ""
            Key = []

            for i in range(56):  # Permutes the block with Permuted choice 1
                temp += (key[TripleDES.PC_1[i] - 1])

            for value in range(28):  # splits the block into two halves
                lkey += (temp[value])

            for value in range(28, 56):
                rkey += (temp[value])

            for i in range(16):
                lkey = op.leftrotate(lkey, TripleDES.iteration[i])  # rotates left block by the given iteration
                rkey = op.leftrotate(rkey, TripleDES.iteration[i])  # rotates right block by the given iteration

                newkey = lkey + rkey  # puts the blocks back together

                temp = ""
                for i in range(48):  # permutes the block again with Permuted choice 2
                    temp += (newkey[TripleDES.PC_2[i] - 1])

                Key.append(temp)  # appends these values to a list

            Keys[n] = Key  # appends the list to a final list.

        return Keys  # returns the final list of the three keys and their subkeys.

    def communicate(self, sender=False, IP='0.0.0.0'):
        """
        This is the method to call when the user wants to communicate between 2 computers
        :param sender: If this computer sends first, set this value to True
        :param IP: If sender is True, then the IP of the receiving computer must be inserted here
        """
        global socketHolder
        if sender:
            socketHolder.connect((IP, 54321))
            print("connected")
        else:
            socketHolder.bind(('0.0.0.0', 54321))
            socketHolder.listen()
            connection, address = socketHolder.accept()
            socketHolder = connection

        a = threading.Thread(target=self.sends)
        b = threading.Thread(target=self.recv)
        a.start()
        b.start()

    def sends(self):
        global socketHolder  # call variable as global
        while True:
            msg = input("")  # placeholder for a way fof getting input
            msg = self.E3DES(msg, "string", "string")
            socketHolder.send(msg.encode(encoding='utf-8', errors='ignore'))  # sends input(add your encryption here)

    def recv(self):
        global socketHolder  # call variable as global
        while True:
            data = socketHolder.recv(4096).decode(encoding='utf-8', errors='strict')  # recieves data from connection
            print(self.D3DES(data, "string", "string"))

